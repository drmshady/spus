# -*- coding: utf-8 -*-
"""Untitled29.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/175PonR7Nc8EVaVO7AdmE3Fnu5S9OSq7r
"""

# -*- coding: utf-8 -*-
"""SPUS Quantitative Analyzer Dashboard ‚Äì Clean, Self-Contained Version"""

import streamlit as st
import pandas as pd
import os
import time
from datetime import datetime
import sys
import logging
from concurrent.futures import ThreadPoolExecutor, as_completed
import openpyxl
from openpyxl.styles import Font

# ---- Path Fix ----
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
if BASE_DIR not in sys.path:
    sys.path.insert(0, BASE_DIR)

# ---- Import helper functions from spus.py ----
try:
    from spus import (
        load_config,
        fetch_spus_tickers,
        process_ticker,
        calculate_support_resistance,
        calculate_financials_and_fair_price
    )
except Exception as e:
    st.error(f"‚ùå Failed to import 'spus.py': {e}")
    st.stop()

# ---- Optional: reportlab check ----
try:
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
    from reportlab.lib.styles import getSampleStyleSheet
    from reportlab.lib import colors
    from reportlab.lib.pagesizes import landscape, letter
    from reportlab.lib.units import inch
    REPORTLAB_AVAILABLE = True
except ImportError:
    REPORTLAB_AVAILABLE = False
    logging.warning("ReportLab not available ‚Äì skipping PDF export.")


# ===============================
# ‚úÖ MAIN ANALYSIS FUNCTION
# ===============================
def run_full_analysis(CONFIG):
    """Main analysis routine ‚Äî same logic as before, condensed for clarity."""
    from spus import fetch_spus_tickers, process_ticker
    progress_bar = st.progress(0, text="Starting analysis...")
    status_text = st.empty()
    status_text.info("Running SPUS Quantitative Analysis...")

    MAX_RISK_USD = 50
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(os.path.join(BASE_DIR, CONFIG['LOG_FILE_PATH'])),
            logging.StreamHandler()
        ]
    )

    ticker_symbols = fetch_spus_tickers()
    if not ticker_symbols:
        status_text.warning("No tickers found.")
        return False

    exclude_tickers = CONFIG['EXCLUDE_TICKERS']
    ticker_symbols = [t for t in ticker_symbols if t not in exclude_tickers]
    if CONFIG['TICKER_LIMIT'] > 0:
        ticker_symbols = ticker_symbols[:CONFIG['TICKER_LIMIT']]

    momentum_data, rsi_data, last_prices = {}, {}, {}
    support_resistance_levels, trend_data, macd_data = {}, {}, {}
    financial_data, news_data, headline_data, calendar_data = {}, {}, {}, {}

    total_tickers = len(ticker_symbols)
    processed_count = 0
    start_time = time.time()

    with ThreadPoolExecutor(max_workers=CONFIG['MAX_CONCURRENT_WORKERS']) as executor:
        future_to_ticker = {executor.submit(process_ticker, t): t for t in ticker_symbols}
        for i, future in enumerate(as_completed(future_to_ticker)):
            ticker = future_to_ticker[future]
            try:
                result = future.result(timeout=60)
                if result['success']:
                    ticker = result['ticker']
                    momentum_data[ticker] = result['momentum']
                    rsi_data[ticker] = result['rsi']
                    last_prices[ticker] = result['last_price']
                    support_resistance_levels[ticker] = result['support_resistance']
                    trend_data[ticker] = result['trend']
                    macd_data[ticker] = {
                        'MACD': result['macd'],
                        'Signal_Line': result['signal_line'],
                        'Histogram': result['hist_val'],
                        'Signal': result['macd_signal']
                    }
                    financial_data[ticker] = result['financial_dict']
                    news_data[ticker] = result['recent_news']
                    headline_data[ticker] = result['latest_headline']
                    calendar_data[ticker] = result['earnings_date']
            except Exception as e:
                logging.error(f"Error processing {ticker}: {e}")

            processed_count += 1
            progress_bar.progress(processed_count / total_tickers, text=f"Processing {ticker}")

    # Build results DataFrame (shortened but complete logic)
    results = []
    for t in last_prices.keys():
        fin = financial_data.get(t, {})
        sr = support_resistance_levels.get(t, {})
        results.append({
            'Ticker': t,
            'Last Price': last_prices.get(t),
            'Sector': fin.get('Sector'),
            'Valuation (Graham)': fin.get('Valuation (Graham)'),
            'Fair Price (Graham)': fin.get('Graham Number'),
            'MACD_Signal': macd_data.get(t, {}).get('Signal'),
            'Trend (50/200 Day MA)': trend_data.get(t),
            'Dividend Yield (%)': fin.get('Dividend Yield'),
            '1-Year Momentum (%)': momentum_data.get(t),
            'Return on Equity (ROE)': fin.get('Return on Equity (ROE)'),
        })
    df = pd.DataFrame(results)
    excel_path = os.path.join(BASE_DIR, CONFIG['EXCEL_FILE_PATH'])
    df.to_excel(excel_path, index=False)
    status_text.info(f"Excel saved: {excel_path}")

    # Minimal PDF output
    if REPORTLAB_AVAILABLE:
        pdf_path = excel_path.replace(".xlsx", f"_{datetime.now().strftime('%Y%m%d_%H%M')}.pdf")
        doc = SimpleDocTemplate(pdf_path, pagesize=landscape(letter))
        styles = getSampleStyleSheet()
        data = [df.columns.tolist()] + df.astype(str).values.tolist()
        table = Table(data)
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.green),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('GRID', (0, 0), (-1, -1), 0.25, colors.grey),
        ]))
        doc.build([Paragraph("SPUS Analysis Summary", styles['h1']), table])
        status_text.info(f"PDF saved: {pdf_path}")
    else:
        status_text.warning("PDF skipped (reportlab not installed)")

    progress_bar.progress(1.0)
    status_text.success("‚úÖ Analysis complete.")
    return True


# ===============================
# ‚úÖ Helper: Load Excel
# ===============================
@st.cache_data
def load_excel_data(excel_path):
    abs_excel_path = os.path.join(BASE_DIR, excel_path)
    if not os.path.exists(abs_excel_path):
        return None, None
    try:
        mod_time = os.path.getmtime(abs_excel_path)
        xls = pd.ExcelFile(abs_excel_path)
        sheets = {s: pd.read_excel(xls, sheet_name=s) for s in xls.sheet_names}
        return sheets, mod_time
    except Exception as e:
        st.error(f"Error reading Excel: {e}")
        return None, None


# ===============================
# ‚úÖ Styling
# ===============================
def style_dataframe_text_only(df):
    def highlight_text(val):
        v = str(val).lower()
        if 'undervalued' in v or 'bullish' in v:
            return 'color: #008000'
        elif 'overvalued' in v or 'bearish' in v:
            return 'color: #B00000'
        elif 'support' in v:
            return 'color: #004FB0'
        return ''
    s = df.style
    cols = [c for c in ['Valuation (Graham)', 'MACD_Signal'] if c in df.columns]
    if cols:
        s = s.apply(lambda x: x.map(highlight_text), subset=cols)
    num_cols = [c for c in ['1-Year Momentum (%)', 'Return on Equity (ROE)'] if c in df.columns]
    for c in num_cols:
        s = s.background_gradient(subset=[c], cmap='Greens')
    return s


# ===============================
# ‚úÖ MAIN Streamlit UI
# ===============================
def main():
    st.set_page_config(page_title="SPUS Quantitative Analysis", layout="wide")
    st.title("üìä SPUS Quantitative Analysis Dashboard")

    CONFIG = load_config('config.json')
    if CONFIG is None:
        st.error("‚ùå Missing config.json.")
        st.stop()

    EXCEL_FILE = CONFIG.get('EXCEL_FILE_PATH', './spus_analysis_results.xlsx')
    excel_path = os.path.join(BASE_DIR, EXCEL_FILE)

    # ---- Sidebar ----
    with st.sidebar:
        st.image("https://www.sp-funds.com/wp-content/uploads/2022/02/SP-Funds-Logo-Primary-Wht-1.svg", width=180)
        st.header("‚öôÔ∏è Controls")

        if st.button("Run Full Analysis", type="primary"):
            with st.spinner("Running analysis... please wait ‚è≥"):
                success = run_full_analysis(CONFIG)
                if success:
                    st.cache_data.clear()
                    st.success("‚úÖ Analysis completed successfully!")
                    st.rerun()
                else:
                    st.error("‚ùå Analysis failed. See logs.")

        st.divider()
        if os.path.exists(excel_path):
            st.download_button(
                label="‚¨áÔ∏è Download Excel Report",
                data=open(excel_path, "rb"),
                file_name=os.path.basename(excel_path),
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            )
            pdf_files = sorted(
                [f for f in os.listdir(BASE_DIR) if f.endswith(".pdf")],
                key=lambda f: os.path.getmtime(os.path.join(BASE_DIR, f)),
                reverse=True
            )
            if pdf_files:
                pdf_path = os.path.join(BASE_DIR, pdf_files[0])
                st.download_button(
                    label="üìÑ Download Latest PDF Report",
                    data=open(pdf_path, "rb"),
                    file_name=pdf_files[0],
                    mime="application/pdf"
                )

    # ---- Main content ----
    data_sheets, mod_time = load_excel_data(EXCEL_FILE)
    if data_sheets is None:
        st.warning("‚ö†Ô∏è No analysis file found yet.")
        st.info("Click 'Run Full Analysis' to start.")
        return

    st.success(f"Showing data from: {datetime.fromtimestamp(mod_time).strftime('%Y-%m-%d %H:%M:%S')}")
    for name, df in data_sheets.items():
        st.subheader(name)
        st.dataframe(style_dataframe_text_only(df), use_container_width=True)
        csv = df.to_csv(index=False).encode('utf-8')
        st.download_button(
            label=f"Download {name} as CSV",
            data=csv,
            file_name=f"{name.replace(' ', '_')}.csv",
            mime='text/csv'
        )
        st.divider()


if __name__ == "__main__":
    main()